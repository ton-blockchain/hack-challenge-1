I looked via an explorer at a random transaction with inbound internal message to find out how logical time of the sender contract correlates with logical time of the receiver contract. I noticed that they usualy differ by 2. I supposed this would also be true during the hack.

I hadn't think about the elegant solution using the fact that the random seed is increased with user-provided number. But I had noticed that you could deduce in the contract code whether a message sent with the current execution to the lottery would win. First I wrote a contract which accepts an external message only if the current logical time would allow to win the lottery. But then I realised that using this way you can only have one attempt per 5 seconds, which is way too slow. I could include a salt in the external message to be added to the seed in order to increase the number of attempts per block, but it would require automating sending different external messages at once -- something I didn't really want to do. So I decided to brute force the salt in the contract itself by invoking it repeatedly sending a message to itself. I had spent around 40 TONs for it, but hadn't won the lottery. So I decided to optimize the contract a little bit: I removed the salt because logical time of each transaction is already changing. I deployed it, sent 20 TONs for the gas fees -- and won the lottery! By the way, because of the lack of time I made my brute force contract to send the prize to anyone in response to receiving a message carrying at least 1 TON -- so someone could have stolen my prize actually.
